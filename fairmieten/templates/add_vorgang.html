{% extends base %}
{% block content %}
<style type="text/tailwindcss">

@layer utilities {
	.vorgang_neu .inner-form p, .diskriminierungart-container .diskriminierungart-row{
	@apply flex 
  }	
  .vorgang_neu .inner-form label, .vorgang_neu .inner-form-diskrimminierung label{
	@apply basis-1/4 text-right mr-4  
  }	
  .vorgang_neu .inner-form-diskrimminierung .button-row{
	@apply basis-3/4    
  }
  .vorgang_neu .inner-form input, select, textarea{
    @apply basis-3/4 w-96 py-2 px-5 mb-4 font-semibold rounded shadow-md hover:bg-violet-100
  }
}
</style>  

<div class="with-sidebar vorgang_neu">
	<aside class="sidebar" id="sidebar">
      <ul >
		{% for item in form_liste %}
		<li>
			<a href="#form-{{ item.key }}" 
				id="nav-{{ item.key }}"
				onclick="setActive(this)">
				{{ item.label }}
			</a>
		</li>
	{% endfor %}
		  </ul>
    </aside>

    <div class="inner-content" id="htmx-inner-content" >
		{% for item in form_liste %}		
		<div id="form-{{ item.key }}" class="form-container" hx-get="{% url 'create_'|add:item.key %}?id={{form.instance.id}}&vorgang_id={{vorgang_id}}"
		hx-trigger="revealed once">
		<div class="form-placeholder">{{vorgang_id}}</div>
		</div>
		{% endfor %}
    </div>
  </div>


<script>
	function initializeObserver() {
		// Intersection Observer setup
		const formContainers = document.querySelectorAll('.form-container');
		const navLinks = document.querySelectorAll('.sidebar a');
		console.log("INITIALIZE OBSERVER");
		// Minimale Sichtbarkeit, die ein Container haben muss
		const MIN_VISIBILITY = 0.1;
    
		const observerOptions = {
			// Positive rootMargin oben für früheres Triggern
			rootMargin: '0px 0px 0px 0px',
			// Dichteres Schwellenwert-Array für genauere Beobachtung
			threshold: [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5]
		};
	
		const observer = new IntersectionObserver((entries) => {
			// Nur Einträge berücksichtigen, die wirklich sichtbar sind
			const visibleEntries = entries.filter(entry => {
				return entry.intersectionRatio >= MIN_VISIBILITY && 
					   entry.boundingClientRect.top <= 0;
			});
	
			if (visibleEntries.length > 0) {
				// Sortiere nach Position und wähle den obersten
				const sortedEntries = visibleEntries.sort((a, b) => {
					// Wenn beide oben sind, nimm den mit höherer Sichtbarkeit
					if (a.boundingClientRect.top <= 0 && b.boundingClientRect.top <= 0) {
						return b.intersectionRatio - a.intersectionRatio;
					}
					// Sonst nach Position sortieren
					return a.boundingClientRect.top - b.boundingClientRect.top;
				});
	
				const activeEntry = sortedEntries[0];
				
				// Nur aktualisieren, wenn sich wirklich etwas geändert hat
				const formId = activeEntry.target.id;
				const navId = 'nav-' + formId.split('-')[1];
				const currentActive = document.querySelector('.sidebar a.active');
				
				// Das hier verhindert flackern usw.
				if (!currentActive || currentActive.id !== navId) {
					console.log(`Aktiviere: ${formId} (Ratio: ${activeEntry.intersectionRatio.toFixed(2)}, Top: ${activeEntry.boundingClientRect.top}px)`);
					navLinks.forEach(link => link.classList.remove('active'));
					document.getElementById(navId).classList.add('active');
				}
			}
		}, observerOptions);

		formContainers.forEach(container => observer.observe(container));

		// Markiere den ersten Anker-Tag als aktiv
		if (navLinks.length > 0) {
			navLinks[0].classList.add('active');
		}
	}

	function handleInputChange(event) {
		const inputElement = event.target;
		inputElement.classList.add('edited'); // Fügen Sie die gewünschte Klasse hinzu
	}

	function setActive(element) {
		// Entferne die Klasse 'active' von allen Links
		var links = document.querySelectorAll('a[id^="nav-"]');
		links.forEach(function(link) {
			link.classList.remove('active');
		});

		// Füge die Klasse 'active' zum angeklickten Link hinzu
		element.classList.add('active');
	}

	// Initialisierung beim Laden der Seite
	document.addEventListener('DOMContentLoaded', function() {
    	initializeObserver();
	});
// Event Listener for htmx:afterSwap
  document.body.addEventListener('htmx:afterSwap', function(event) {
    // Überprüfen, ob das nachgeladene Element die gesamte Seite ist
    console.log("Target id:  "+event.detail.target.id);
	if (event.detail.target.id == 'htmx-content') {
    	initializeObserver();
	}
	// Event Listener for input fields
	const inputFields = document.querySelectorAll('input, textarea, select');
	inputFields.forEach(input => {
	input.addEventListener('input', handleInputChange);
	});
    
  });
  </script>
{% endblock %}
